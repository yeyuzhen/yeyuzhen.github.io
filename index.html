<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yeyuzhen.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Eason&#39;s Blog">
<meta property="og:url" content="https://yeyuzhen.github.io/index.html">
<meta property="og:site_name" content="Eason&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Eason Ye">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yeyuzhen.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Eason's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Eason's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Eason Ye</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/11/12/redis_ae_client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/12/redis_ae_client/" class="post-title-link" itemprop="url">Redis AE异步事件库实例分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-12 12:40:21" itemprop="dateCreated datePublished" datetime="2023-11-12T12:40:21+08:00">2023-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/11/12/redis_ae_client/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/11/12/redis_ae_client/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>注：这是2018年2月写的旧博文，转载到此。</p>
</blockquote>
<p>Redis使用了一个称为“A simple event-driven programming library”的自制异步事件库(以下简称“AE”)。整个事件库的代码量少于1k行，是个优秀的C异步事件库学习材料。</p>
<h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><blockquote>
<p>版本 Redis 4.0.8</p>
</blockquote>
<p>redis的src目录下，ae开头的几个文件就是AE事件库的源码。</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ae.h</td>
<td>AE事件库接口定义</td>
</tr>
<tr>
<td>ae.c</td>
<td>AE事件库实现</td>
</tr>
<tr>
<td>ae_epoll.c</td>
<td>epoll绑定</td>
</tr>
<tr>
<td>ae_evport.c</td>
<td>evport绑定</td>
</tr>
<tr>
<td>ae_kqueue.c</td>
<td>kqueue绑定</td>
</tr>
<tr>
<td>ae_select.c</td>
<td>select绑定</td>
</tr>
</tbody></table>
<p>文件数量有点多，我们把IO多路复用的绑定都“精简”掉。在“ae.c”的开头有这么一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Include the best multiplexing layer supported by this system.</span><br><span class="line"> * The following should be ordered by performances, descending. */</span><br><span class="line">#ifdef HAVE_EVPORT</span><br><span class="line">#include &quot;ae_evport.c&quot;</span><br><span class="line">#else</span><br><span class="line">    #ifdef HAVE_EPOLL</span><br><span class="line">    #include &quot;ae_epoll.c&quot;</span><br><span class="line">    #else</span><br><span class="line">        #ifdef HAVE_KQUEUE</span><br><span class="line">        #include &quot;ae_kqueue.c&quot;</span><br><span class="line">        #else</span><br><span class="line">        #include &quot;ae_select.c&quot;</span><br><span class="line">        #endif</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>Redis根据所处系统的不同，包含不同的IO多路复用实现代码。每种IO多路复用都实现了以下的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct aeApiState;</span><br><span class="line">static int aeApiCreate(aeEventLoop *eventLoop);</span><br><span class="line">static int aeApiResize(aeEventLoop *eventLoop, int setsize);</span><br><span class="line">static void aeApiFree(aeEventLoop *eventLoop);</span><br><span class="line">static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask);</span><br><span class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask);</span><br><span class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp);</span><br><span class="line">static char *aeApiName(void);</span><br></pre></td></tr></table></figure>
<p>任意的IO多路复用技术，只要封装出以上的接口就可以被AE事件库作为底层实现使用。我们“精简”掉4个IO多路复用绑定代码之后，就剩下“ae.h、ae.c”这两个文件了。</p>
<h1 id="AE事件模型"><a href="#AE事件模型" class="headerlink" title="AE事件模型"></a>AE事件模型</h1><p>AE异步事件库支持以下的事件类型：</p>
<ul>
<li>文件事件</li>
<li>定时器事件</li>
</ul>
<p>Redis本身是一个KV数据库，主要就是接收客户端的查询请求并返回结果，以及对KV数据的有效性维护。所以文件事件(IO事件)和定时器事件就足以支撑服务端的全部功能。</p>
<h4 id="文件-IO-事件"><a href="#文件-IO-事件" class="headerlink" title="文件(IO)事件"></a>文件(IO)事件</h4><p>与文件事件相关的定义和接口有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define AE_NONE 0</span><br><span class="line">#define AE_READABLE 1</span><br><span class="line">#define AE_WRITABLE 2</span><br><span class="line"></span><br><span class="line">typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);</span><br><span class="line"></span><br><span class="line">/* File event structure */</span><br><span class="line">typedef struct aeFileEvent &#123;</span><br><span class="line">    int mask; /* one of AE_(READABLE|WRITABLE) */</span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    void *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData);</span><br><span class="line">void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);</span><br></pre></td></tr></table></figure>

<h4 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h4><p>与定时器事件相关的定义和接口有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</span><br><span class="line">typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</span><br><span class="line"></span><br><span class="line">/* Time event structure */</span><br><span class="line">typedef struct aeTimeEvent &#123;</span><br><span class="line">    long long id; /* time event identifier. */</span><br><span class="line">    long when_sec; /* seconds */</span><br><span class="line">    long when_ms; /* milliseconds */</span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    void *clientData;</span><br><span class="line">    struct aeTimeEvent *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line">long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,</span><br><span class="line">        aeTimeProc *proc, void *clientData,</span><br><span class="line">        aeEventFinalizerProc *finalizerProc);</span><br><span class="line">int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);</span><br></pre></td></tr></table></figure>
<p>每种事件类型都定义了回调函数、事件结构体、事件添加&#x2F;删除接口，以支持该类型事件的操作。</p>
<h1 id="AE异步事件库的典型用法"><a href="#AE异步事件库的典型用法" class="headerlink" title="AE异步事件库的典型用法"></a>AE异步事件库的典型用法</h1><p>下面的例子使用AE事件库进行网络读写和定时器操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* file: example-libae.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;ae.h&gt;</span><br><span class="line"></span><br><span class="line">static const int MAX_SETSIZE = 64;</span><br><span class="line">static const int MAX_BUFSIZE = 128;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">file_cb(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[MAX_BUFSIZE] = &#123;0&#125;;</span><br><span class="line">    int rc;</span><br><span class="line"></span><br><span class="line">    rc = read(fd, buf, MAX_BUFSIZE);</span><br><span class="line">    if (rc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        aeStop(eventLoop);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        buf[rc - 1] = &#x27;\0&#x27;;  /* 最后一个字符是回车 */</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;file_cb, read %s, fd %d, mask %d, clientData %s\n&quot;, buf, fd, mask, (char *)clientData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">timer_cb(struct aeEventLoop *eventLoop, long long id, void *clientData)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;timer_cb, timestamp %ld, id %lld, clientData %s\n&quot;, time(NULL), id, (char *)clientData);</span><br><span class="line">    return (5 * 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_fin_cb(struct aeEventLoop *eventLoop, void *clientData)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;timer_fin_cb, timestamp %ld, clientData %s\n&quot;, time(NULL), (char *)clientData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    aeEventLoop *ae;</span><br><span class="line">    long long id;</span><br><span class="line">    int rc;</span><br><span class="line"></span><br><span class="line">    ae = aeCreateEventLoop(MAX_SETSIZE);</span><br><span class="line">    if (!ae)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;create event loop error\n&quot;);</span><br><span class="line">        goto err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 添加文件IO事件 */</span><br><span class="line">    rc = aeCreateFileEvent(ae, STDIN_FILENO, AE_READABLE, file_cb, (void *)&quot;test ae file event&quot;);</span><br><span class="line"></span><br><span class="line">    /* 添加定时器事件 */</span><br><span class="line">    id = aeCreateTimeEvent(ae, 5 * 1000, timer_cb, (void *)&quot;test ae time event&quot;, timer_fin_cb);</span><br><span class="line">    if (id &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;create time event error\n&quot;);</span><br><span class="line">        aeDeleteEventLoop(ae);</span><br><span class="line">        goto err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aeMain(ae);</span><br><span class="line"></span><br><span class="line">    aeDeleteEventLoop(ae);</span><br><span class="line">    return (0);</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    return (-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把这个文件放在Redis的deps&#x2F;hiredis&#x2F;examples目录下，修改hiredis目录的Makefile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AE_DIR=/path/to/redis/src</span><br><span class="line">example-libae: examples/example-libae.c $(STLIBNAME)</span><br><span class="line">    $(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(AE_DIR) $&lt; $(AE_DIR)/ae.o $(AE_DIR)/zmalloc.o $(AE_DIR)/../deps/jemalloc/lib/libjemalloc.a -pthread $(STLIBNAME)</span><br></pre></td></tr></table></figure>
<p>编译执行看一下效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make example-libae</span><br><span class="line">$ examples/example-libae</span><br><span class="line">123456</span><br><span class="line">file_cb, read 123456, fd 0, mask 1, clientData test ae file event</span><br><span class="line">timer_cb, timestamp 1519137082, id 0, clientData test ae time event</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>可以看到AE异步事件库的使用还是比较简单，没有复杂的概念和接口。</p>
<h1 id="AE事件循环"><a href="#AE事件循环" class="headerlink" title="AE事件循环"></a>AE事件循环</h1><p>一个异步事件库除了事件模型外，最重要的部分就是事件循环了。来看看AE的事件循环“aeMain”是怎么实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* file: ae.c */</span><br><span class="line">void aeMain(aeEventLoop *eventLoop) &#123;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    while (!eventLoop-&gt;stop) &#123; /* 运行状态判断 */</span><br><span class="line">        if (eventLoop-&gt;beforesleep != NULL)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop); /* 事件循环前回调执行 */</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来“aeProcessEvents”函数才是事件循环的主体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/* file: ae.c */</span><br><span class="line"></span><br><span class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags)</span><br><span class="line">&#123;</span><br><span class="line">    int processed = 0, numevents;</span><br><span class="line"></span><br><span class="line">    /* 如果啥事件都不关注，立即返回 */</span><br><span class="line">    if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0;</span><br><span class="line"></span><br><span class="line">    if (eventLoop-&gt;maxfd != -1 ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        aeTimeEvent *shortest = NULL;</span><br><span class="line">        struct timeval tv, *tvp;</span><br><span class="line"></span><br><span class="line">       /* 略去计算tvp的代码 */</span><br><span class="line">        …… ……</span><br><span class="line"></span><br><span class="line">        /* 调用IO多路复用接口 */</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        /* 略去IO多路复用后回调执行代码 */</span><br><span class="line">        …… ……</span><br><span class="line"></span><br><span class="line">        for (j = 0; j &lt; numevents; j++) &#123; /* 循环处理IO事件 */</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            int mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            int fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            int rfired = 0;</span><br><span class="line"></span><br><span class="line">            /* 执行读回调函数 */</span><br><span class="line">            if (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                rfired = 1;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); </span><br><span class="line">            &#125;</span><br><span class="line">            /* 执行写回调函数 */</span><br><span class="line">            if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                if (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); </span><br><span class="line">            &#125;</span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 执行定时器事件 */</span><br><span class="line">    if (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    return processed; /* return the number of processed file/time events */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在“aeProcessEvents”函数主体中，对于文件(IO)事件的处理逻辑已经比较清晰，调用IO多路复用接口并循环处理返回的有效文件描述符。定时器事件在“processTimeEvents”函数中处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* file: ae.c */</span><br><span class="line"></span><br><span class="line">static int processTimeEvents(aeEventLoop *eventLoop) &#123;</span><br><span class="line">    int processed = 0;</span><br><span class="line">    aeTimeEvent *te, *prev;</span><br><span class="line">    long long maxId;</span><br><span class="line">    time_t now = time(NULL);</span><br><span class="line"></span><br><span class="line">    /* 发现系统时间修改过，为防止定时器永远无法执行，将定时器设置为立即执行 */</span><br><span class="line">    if (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        while(te) &#123;</span><br><span class="line">            te-&gt;when_sec = 0;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    prev = NULL;</span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId-1;</span><br><span class="line">    while(te) &#123;</span><br><span class="line">        long now_sec, now_ms;</span><br><span class="line">        long long id;</span><br><span class="line"></span><br><span class="line">        /* 略去删除失效定时器代码 */</span><br><span class="line">        …… ……</span><br><span class="line"> </span><br><span class="line">        /* 略去作者都注释说没什么用的代码囧 */</span><br><span class="line">        …… ……</span><br><span class="line"></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        if (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            int retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            /* 执行回调函数 */</span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            if (retval != AE_NOMORE) &#123;</span><br><span class="line">                /* 需要继续保留的定时器，根据回调函数的返回值重新计算延迟时间 */</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* 无需保留的定时器，打上删除标识 */</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AE库的定时器事件很“简单粗暴”的使用了链表。新事件都往表头添加(详见“aeCreateFileEvent”函数实现)，循环遍历链表执行定时器事件。没有使用复杂的时间堆和时间轮，简单可用，只是查找和执行定时器事件的事件复杂度都是O(n)。作者在注释中也解释说，现在基于链表的定时器事件处理机制已经足够Redis使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Search the first timer to fire.</span><br><span class="line"> * This operation is useful to know how many time the select can be</span><br><span class="line"> * put in sleep without to delay any event.</span><br><span class="line"> * If there are no timers NULL is returned.</span><br><span class="line"> *</span><br><span class="line"> * Note that&#x27;s O(N) since time events are unsorted.</span><br><span class="line"> * Possible optimizations (not needed by Redis so far, but...):</span><br><span class="line"> * 1) Insert the event in order, so that the nearest is just the head.</span><br><span class="line"> *    Much better but still insertion or deletion of timers is O(N).</span><br><span class="line"> * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从前面的分析可以看到，AE异步事件库本身的实现很简洁，却支撑起了业界最流行的KV内存数据库的核心功能。让我想起了业界的一句鸡汤，“要么架构优雅到不怕Bug，要么代码简洁到不会有Bug”。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a target="_blank" rel="noopener" href="https://my.oschina.net/u/917596/blog/161077">事件库之Redis自己的事件模型-ae</a>，by C_Z</p>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans">创意共享4.0许可证</a>）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/11/12/cython_fly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/12/cython_fly/" class="post-title-link" itemprop="url">用Cython加速Python到“起飞”</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-12 12:40:03" itemprop="dateCreated datePublished" datetime="2023-11-12T12:40:03+08:00">2023-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/11/12/cython_fly/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/11/12/cython_fly/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>注：这是2018年2月写的旧博文，转载到此。</p>
</blockquote>
<p>事先声明，标题没有把“Python”错打成“Cython”，因为要讲的就是名为“Cython”的东西。</p>
<p><a target="_blank" rel="noopener" href="http://cython.org/">Cython</a>是让Python脚本支持C语言扩展的编译器，Cython能够将Python+C混合编码的.pyx脚本转换为C代码，主要用于优化Python脚本性能或Python调用C函数库。由于Python固有的性能差的问题，用C扩展Python成为提高Python性能常用方法，Cython算是较为常见的一种扩展方式。</p>
<p>我们可以对比一下业界主流的几种Python扩展支持C语言的方案：<br><img src="/../images/python_support_c.png" alt="有试用版水印，是因为穷T_T"></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/ctypes.html">ctypes</a>是Python标准库支持的方案，直接在Python脚本中导入C的.so库进行调用，简单直接。<a target="_blank" rel="noopener" href="http://www.swig.org/translations/chinese/index.html">swig</a>是一个通用的让高级脚本语言扩展支持C的工具，自然也是支持Python的。ctypes没玩过，不做评价。以c语言程序性能为基准的话，cython封装后下降20%，swig封装后下降70%。功能方面，swig对结构体和回调函数都要使用typemap进行手工编写转换规则，typemap规则写起来略复杂，体验不是很好。cython在结构体和回调上也要进行手工编码处理，不过比较简单。</p>
<h1 id="Cython简单实例"><a href="#Cython简单实例" class="headerlink" title="Cython简单实例"></a>Cython简单实例</h1><p>我们尝试用Cython，让Python脚本调用C语言写的打印“Hello World”的函数，来熟悉一下Cython的玩法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*filename: hello_world.h */</span><br><span class="line">void print_hello_world();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*filename: hello_world.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;hello_world.h&quot;</span><br><span class="line"></span><br><span class="line">void print_hello_world()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arch, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    print_hello_world();</span><br><span class="line">    return (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#file: hello_world.pyx</span><br><span class="line"></span><br><span class="line">cdef extern from &quot;hello_world.h&quot;:</span><br><span class="line">    void print_hello_world()</span><br><span class="line"></span><br><span class="line">def cython_print_hello_world():</span><br><span class="line">    print_hello_world()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#filename: Makefile</span><br><span class="line">all: hello_world cython_hello_world</span><br><span class="line"></span><br><span class="line">hello_world:</span><br><span class="line">    gcc hello_world.c -c hello_world.c</span><br><span class="line">    gcc hello_world.o -o hello_world </span><br><span class="line"></span><br><span class="line">cython:</span><br><span class="line">    cython cython_hello_world.pyx</span><br><span class="line"></span><br><span class="line">cython_hello_world: cython</span><br><span class="line">    gcc cython_hello_world.c -fPIC -c</span><br><span class="line">    gcc -shared -lpython2.7 -o cython_hello_world.so hello_world.o cython_hello_world.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf hello_world hello_world.o cython_hello_world.so cython_hello_world.c cython_hello_world.o</span><br></pre></td></tr></table></figure>
<p>用Cython扩展C，最重要的就是编写.pyx脚本文件。.pyx脚本是Python调用C的桥梁，.pyx脚本中即能用Python语法写，也可以用类C语法写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make all    # 详细的编译过程可以看Makefile中的相关指令</span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import cython_hello_world</span><br><span class="line">&gt;&gt;&gt; cython_hello_world.cython_print_hello_world()</span><br><span class="line">hello world...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们成功的在Python解释器中调用了C语言实现的函数。</p>
<h1 id="Cython的注意事项"><a href="#Cython的注意事项" class="headerlink" title="Cython的注意事项"></a>Cython的注意事项</h1><p>所有工具&#x2F;语言的简单使用都是令人愉快的，但是深入细节就会发现处处“暗藏杀机”。最近是项目需要扩展C底层库给Python调用，所以引入了Cython。实践过程中踩了很多坑，熬了很多夜T_T。遇到了以下几点需要特别注意的点：</p>
<blockquote>
<ol>
<li>.pyx中用cdef定义的东西，除类以外对.py都是不可见的；</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>.py中是不能操作C类型的，如果想在.py中操作C类型就要在.pyx中从python object转成C类型或者用含有set&#x2F;get方法的C类型包裹类；</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>虽然Cython能对Python的str和C的“char *”之间进行自动类型转换，但是对于“char a[n]”这种固定长度的字符串是无法自动转换的。需要使用Cython的libc.string.strcpy进行显式拷贝；</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>回调函数需要用函数包裹，再通过C的“void *”强制转换后才能传入C函数。</li>
</ol>
</blockquote>
<h2 id="1-pyx中用cdef定义的类型，除类以外对-py都不可见"><a href="#1-pyx中用cdef定义的类型，除类以外对-py都不可见" class="headerlink" title="1. .pyx中用cdef定义的类型，除类以外对.py都不可见"></a>1. .pyx中用cdef定义的类型，除类以外对.py都不可见</h2><p>我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#file: invisible.pyx</span><br><span class="line">cdef inline cdef_function():</span><br><span class="line">    print(&#x27;cdef_function&#x27;)</span><br><span class="line"></span><br><span class="line">def def_function():</span><br><span class="line">    print(&#x27;def_function&#x27;)</span><br><span class="line"></span><br><span class="line">cdef int cdef_value</span><br><span class="line"></span><br><span class="line">def_value = 999</span><br><span class="line"></span><br><span class="line">cdef class cdef_class:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.value = 1</span><br><span class="line"></span><br><span class="line">class def_class:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.value = 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#file: test_visible.py</span><br><span class="line">import invisible</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;invisible.__dict__&#x27;, invisible.__dict__)</span><br></pre></td></tr></table></figure>
<p>输出的invisible模块的成员如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python invisible.py</span><br><span class="line">&#123;</span><br><span class="line">&#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, </span><br><span class="line">&#x27;def_class&#x27;: &lt;class invisible.def_class at 0x10feed1f0&gt;, </span><br><span class="line">&#x27;__file__&#x27;: &#x27;/git/EasonCodeShare/cython_tutorials/invisible-for-py/invisible.so&#x27;, </span><br><span class="line">&#x27;call_all_in_pyx&#x27;: &lt;built-in function call_all_in_pyx&gt;, </span><br><span class="line">&#x27;__pyx_unpickle_cdef_class&#x27;: &lt;built-in function __pyx_unpickle_cdef_class&gt;, </span><br><span class="line">&#x27;__package__&#x27;: None, </span><br><span class="line">&#x27;__test__&#x27;: &#123;&#125;, </span><br><span class="line">&#x27;cdef_class&#x27;: &lt;type &#x27;invisible.cdef_class&#x27;&gt;, </span><br><span class="line">&#x27;__name__&#x27;: &#x27;invisible&#x27;, </span><br><span class="line">&#x27;def_value&#x27;: 999, </span><br><span class="line">&#x27;def_function&#x27;: &lt;built-in function def_function&gt;, </span><br><span class="line">&#x27;__doc__&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>我们在.pyx用cdef定义的函数cdef_function、变量cdef_value都看不到了，只有类cdef_class能可见。所以，使用过程中要注意可见性问题，不要错误的在.py中尝试使用不可见的模块成员。</p>
<h2 id="2-py传递C结构体类型"><a href="#2-py传递C结构体类型" class="headerlink" title="2. .py传递C结构体类型"></a>2. .py传递C结构体类型</h2><p>Cython扩展C的能力仅限于.pyx脚本中，.py脚本还是只能用纯Python。如果你在C中定义了一个结构，要从Python脚本中传进来就只能在.pyx手工转换一次，或者用包裹类传进来。我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*file: person_info.h */</span><br><span class="line">typedef struct person_info_t</span><br><span class="line">&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char *gender;</span><br><span class="line">&#125;person_info;</span><br><span class="line"></span><br><span class="line">void print_person_info(char *name, person_info *info);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//file: person_info.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;person_info.h&quot;</span><br><span class="line"></span><br><span class="line">void print_person_info(char *name, person_info *info)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;name: %s, age: %d, gender: %s\n&quot;,</span><br><span class="line">            name, info-&gt;age, info-&gt;gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#file: cython_person_info.pyx</span><br><span class="line">cdef extern from &quot;person_info.h&quot;:</span><br><span class="line">    struct person_info_t:</span><br><span class="line">        int age</span><br><span class="line">        char *gender</span><br><span class="line">    ctypedef person_info_t person_info</span><br><span class="line"></span><br><span class="line">    void print_person_info(char *name, person_info *info)</span><br><span class="line"></span><br><span class="line">def cyprint_person_info(name, info):</span><br><span class="line">    cdef person_info pinfo</span><br><span class="line">    pinfo.age = info.age</span><br><span class="line">    pinfo.gender = info.gender</span><br><span class="line">    print_person_info(name, &amp;pinfo)</span><br></pre></td></tr></table></figure>
<p>因为“cyprint_person_info”的参数只能是python object，所以我们要在函数中手工编码转换一下类型再调用C函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#file: test_person_info.py</span><br><span class="line">from cython_person_info import cyprint_person_info</span><br><span class="line"></span><br><span class="line">class person_info(object):</span><br><span class="line">    age = None</span><br><span class="line">    gender = None</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    info = person_info()</span><br><span class="line">    info.age = 18</span><br><span class="line">    info.gender = &#x27;male&#x27;</span><br><span class="line">    </span><br><span class="line">    cyprint_person_info(&#x27;handsome&#x27;, info)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test_person_info.py</span><br><span class="line">name: handsome, age: 18, gender: male</span><br></pre></td></tr></table></figure>
<p>能正常调用到C函数。可是，这样存在一个问题，如果我们C的结构体字段很多，我们每次从.py脚本调用C函数都要手工编码转换一次类型数据就会很麻烦。还有更好的一个办法就是给C的结构体提供一个包裹类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#file: cython_person_info.pyx</span><br><span class="line">from libc.stdlib cimport malloc, free</span><br><span class="line">cdef extern from &quot;person_info.h&quot;:</span><br><span class="line">    struct person_info_t:</span><br><span class="line">        int age</span><br><span class="line">        char *gender</span><br><span class="line">    ctypedef person_info_t person_info</span><br><span class="line"></span><br><span class="line">    void print_person_info(char *name, person_info *info)</span><br><span class="line"></span><br><span class="line">def cyprint_person_info(name, person_info_wrap info):</span><br><span class="line">    print_person_info(name, info.ptr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cdef class person_info_wrap(object):</span><br><span class="line">    cdef person_info *ptr</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.ptr = &lt;person_info *&gt;malloc(sizeof(person_info))</span><br><span class="line">    </span><br><span class="line">    def __del__(self):</span><br><span class="line">        free(self.ptr)</span><br><span class="line">    </span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.ptr.age</span><br><span class="line">    @age.setter</span><br><span class="line">    def age(self, value):</span><br><span class="line">        self.ptr.age = value</span><br><span class="line">    </span><br><span class="line">    @property</span><br><span class="line">    def gender(self):</span><br><span class="line">        return self.ptr.gender</span><br><span class="line">    @gender.setter</span><br><span class="line">    def gender(self, value):</span><br><span class="line">        self.ptr.gender = value</span><br></pre></td></tr></table></figure>
<p>我们定义了一个“person_info”结构体的包裹类“person_info_wrap”，并提供了成员set&#x2F;get方法，这样就可以在.py中直接赋值了。减少了在.pyx中转换数据类型的步骤，能有效的提高性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#file: test_person_info.py</span><br><span class="line">from cython_person_info import cyprint_person_info, person_info_wrap</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    info_wrap = person_info_wrap()</span><br><span class="line">    info_wrap.age = 88</span><br><span class="line">    info_wrap.gender = &#x27;mmmale&#x27;</span><br><span class="line">    </span><br><span class="line">    cyprint_person_info(&#x27;hhhandsome&#x27;, info_wrap)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test_person_info.py </span><br><span class="line">name: hhhandsome, age: 88, gender: mmmale</span><br></pre></td></tr></table></figure>

<h2 id="3-python的str传递给C固定长度字符串要用strcpy"><a href="#3-python的str传递给C固定长度字符串要用strcpy" class="headerlink" title="3. python的str传递给C固定长度字符串要用strcpy"></a>3. python的str传递给C固定长度字符串要用strcpy</h2><p>正如在C语言中，字符串之间不能直接赋值拷贝，而要使用strcpy复制一样，python的str和C字符串之间也要用cython封装的libc.string.strcpy函数来拷贝。我们稍微修改上一个例子，让person_info结构体的gender成员为16字节长的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*file: person_info.h */</span><br><span class="line">typedef struct person_info_t</span><br><span class="line">&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char gender[16];</span><br><span class="line">&#125;person_info;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#file: cython_person_info.pyx</span><br><span class="line">cdef extern from &quot;person_info.h&quot;:</span><br><span class="line">    struct person_info_t:</span><br><span class="line">        int age</span><br><span class="line">        char gender[16]</span><br><span class="line">    ctypedef person_info_t person_info</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#file: test_person_info.py</span><br><span class="line">from cython_person_info import cyprint_person_info, person_info_wrap</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    info_wrap = person_info_wrap()</span><br><span class="line">    info_wrap.age = 88</span><br><span class="line">    info_wrap.gender = &#x27;mmmale&#x27;</span><br><span class="line">    </span><br><span class="line">    cyprint_person_info(&#x27;hhhandsome&#x27;, info_wrap)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ python test_person_info.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test_person_info.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    info_wrap.gender = &#x27;mmmale&#x27;</span><br><span class="line">  File &quot;cython_person_info.pyx&quot;, line 39, in cython_person_info.person_info_wrap.gender.__set__</span><br><span class="line">    self.ptr.gender = value</span><br><span class="line">  File &quot;stringsource&quot;, line 93, in carray.from_py.__Pyx_carray_from_py_char</span><br><span class="line">IndexError: not enough values found during array assignment, expected 16, got 6</span><br></pre></td></tr></table></figure>
<p>cython转换和make时候是没有报错的，运行的时候提示“IndexError: not enough values found during array assignment, expected 16, got 6”，其实就是6字节长的“mmmale”赋值给了person_info结构体的“char gender[16]”成员。我们用strcpy来实现字符串之间的拷贝就ok了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#file: cython_person_info.pyx</span><br><span class="line">from libc.string cimport strcpy</span><br><span class="line">…… ……</span><br><span class="line">cdef class person_info_wrap(object):</span><br><span class="line">    cdef person_info *ptr</span><br><span class="line">    …… ……</span><br><span class="line">    @property</span><br><span class="line">    def gender(self):</span><br><span class="line">        return self.ptr.gender</span><br><span class="line">    @gender.setter</span><br><span class="line">    def gender(self, value):</span><br><span class="line">        strcpy(self.ptr.gender, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ python test_person_info.py </span><br><span class="line">name: hhhandsome, age: 88, gender: mmmale</span><br></pre></td></tr></table></figure>
<p>赋值拷贝正常，成功将“mmmale”拷贝给了结构体的gender成员。</p>
<h2 id="4-用回调函数作为参数的C函数封装"><a href="#4-用回调函数作为参数的C函数封装" class="headerlink" title="4. 用回调函数作为参数的C函数封装"></a>4. 用回调函数作为参数的C函数封装</h2><p>C中的回调函数比较特殊，用户传入回调函数来定制化的处理数据。Cython官方提供了封装带有回调函数参数的<a target="_blank" rel="noopener" href="https://github.com/cython/cython/tree/master/Demos/callback">例子</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//file: cheesefinder.h</span><br><span class="line">typedef void (*cheesefunc)(char *name, void *user_data);</span><br><span class="line">void find_cheeses(cheesefunc user_func, void *user_data);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//file: cheesefinder.c</span><br><span class="line">#include &quot;cheesefinder.h&quot;</span><br><span class="line"></span><br><span class="line">static char *cheeses[] = &#123;</span><br><span class="line">  &quot;cheddar&quot;,</span><br><span class="line">  &quot;camembert&quot;,</span><br><span class="line">  &quot;that runny one&quot;,</span><br><span class="line">  0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void find_cheeses(cheesefunc user_func, void *user_data) &#123;</span><br><span class="line">  char **p = cheeses;</span><br><span class="line">  while (*p) &#123;</span><br><span class="line">    user_func(*p, user_data);</span><br><span class="line">    ++p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#file: cheese.pyx</span><br><span class="line">cdef extern from &quot;cheesefinder.h&quot;:</span><br><span class="line">    ctypedef void (*cheesefunc)(char *name, void *user_data)</span><br><span class="line">    void find_cheeses(cheesefunc user_func, void *user_data)</span><br><span class="line"></span><br><span class="line">def find(f):</span><br><span class="line">    find_cheeses(callback, &lt;void*&gt;f)</span><br><span class="line"></span><br><span class="line">cdef void callback(char *name, void *f):</span><br><span class="line">    (&lt;object&gt;f)(name.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cheese</span><br><span class="line"></span><br><span class="line">def report_cheese(name):</span><br><span class="line">    print(&quot;Found cheese: &quot; + name)</span><br><span class="line"></span><br><span class="line">cheese.find(report_cheese)</span><br></pre></td></tr></table></figure>
<p>关键的步骤就是在.pyx中定义一个和C的回调函数相同的回调包裹函数，如上的“cdef void callback(char *name, void *f)”。之后，将.py中的函数作为参数传递给包裹函数，并在包裹函数中转换成函数对象进行调用。</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>更进一步的研究Cython可以参考官方文档和相关书籍：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://cython.readthedocs.io/en/latest/index.html#">Cython 0.28a0 documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Cython-Programmers-Kurt-W-Smith/dp/1491901551">Cython A Guide for Python Programmers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Learning-Cython-Programming-Philip-Herron/dp/1783280794">Learning Cython Programming</a></li>
</ul>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans">创意共享4.0许可证</a>）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/11/11/diagram_redis_protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/diagram_redis_protocol/" class="post-title-link" itemprop="url">图解Redis通信协议</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-11 23:22:20" itemprop="dateCreated datePublished" datetime="2023-11-11T23:22:20+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/11/11/diagram_redis_protocol/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/11/11/diagram_redis_protocol/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>注：这是2018年2月写的旧博文，转载到此。</p>
</blockquote>
<h1 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a>Redis 协议</h1><p>Redis客户端和服务端之间使用一种名为RESP(REdis Serialization Protocol)的二进制安全文本协议进行通信。RESP设计的十分精巧，下面是一张完备的协议描述图：<br><img src="/../images/redis_protocol_diagram.png" alt="redis protocol"></p>
<p>#举个栗子<br>用SET命令来举例说明RESP协议的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure>
<p>实际发送的请求数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$5\r\nHello\r\n</span><br></pre></td></tr></table></figure>
<p>实际收到的响应数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+OK\r\n</span><br></pre></td></tr></table></figure>
<p>每种命令对应的回复类型，可以查询Redis官网的命令列表<a target="_blank" rel="noopener" href="https://redis.io/commands">Command reference</a>。更详细的协议说明请参考Redis官方协议规范<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">Redis Protocol specification</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 通信协议(protocol)，<a target="_blank" rel="noopener" href="http://redisdoc.com/topic/protocol.html">http://redisdoc.com/topic/protocol.html</a></p>
<p>[2] Redis Protocol specification，<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a></p>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans">创意共享4.0许可证</a>）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/11/11/extremely_simple_anki_deck_struction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/extremely_simple_anki_deck_struction/" class="post-title-link" itemprop="url">极简 Anki 牌组结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-11 22:18:16" itemprop="dateCreated datePublished" datetime="2023-11-11T22:18:16+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/11/11/extremely_simple_anki_deck_struction/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/11/11/extremely_simple_anki_deck_struction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>注：这是2020年1月写的旧博文，转载到此。</p>
</blockquote>
<h1 id="Anki是什么？"><a href="#Anki是什么？" class="headerlink" title="Anki是什么？"></a>Anki是什么？</h1><p>本文假定你是个Anki用户，并不会对Anki基础知识进行介绍。对Anki不熟悉的读者可以阅读Anki英文官网（<a target="_blank" rel="noopener" href="https://apps.ankiweb.net/">Anki - powerful, intelligent flashcards</a>），或Anki中国（<a target="_blank" rel="noopener" href="https://www.ankichina.net/anki20.html">Anki–近乎完美的记忆神器</a>）的介绍内容。</p>
<h1 id="正确使用牌组"><a href="#正确使用牌组" class="headerlink" title="正确使用牌组"></a>正确使用牌组</h1><p>“正确使用牌组”是<a target="_blank" rel="noopener" href="https://www.ankichina.net/Index/ankishouce">官方 Anki 手册</a>上对 Anki 牌组功能的使用建议，内容如下：</p>
<blockquote>
<p>牌组被设计成将你的内容分成你想单独学习的大类，如英语、地理等等。 你可能会想创建许多小的牌组，以保持你的内容有条理，如“我的地理书第1章”，或“食品动词”，但这是不推荐的，有以下原因：</p>
<ul>
<li><p>许多小牌组意味着你最终会以可识别的顺序复习卡片。 无论是因为你依次点击每一个牌组（这是缓慢的），或你在一个单一的父级牌组上增加了一些牌组，你最终会看到所有的“第1章”或“食物动词”卡片在一起。 这使得回答卡片更容易，因为你可以从上下文猜测他们，从而导致较弱的记忆。 当你需要回忆单词或Anki外的短语时，你不会有充足的可被证明的相关内容。</p>
</li>
<li><p>Anki不是设计来处理许多牌组（超过几十个），它会慢下来，当你添加更多的–尤其是如果你在一个移动客户端的情况下。一些额外的牌组不会产生明显的差异，但是如果你有许多牌组，延误将开始增加。</p>
</li>
</ul>
<p><strong>使用标签和&#x2F;或字段来分类内容，替代创建许多小的牌组，这是一个更好的主意。</strong> 例如替代创建一个“食物动词”，你可以把这些卡片添加到你的主要语言学习牌组，并用“食物”和“动词”来标记卡片。每个卡片可以有多个标签，这意味着你可以做的事情，如寻找所有的动词，或所有与食品有关的词汇，或所有的动词与食品有关。</p>
<p>对于那些喜欢保持非常有条理的，您可以添加字段到您的笔记分类的内容，如“书”，“页”等。 Anki支持特定字段的搜索，这意味着你可以做一个“图书搜索：‘我的书’页码：63”马上找到你要找的。</p>
<p>Anki的定制学习和筛选牌组特点使其特别强大，因为你可以从搜索条件创建临时牌组。这允许您在大多数时间（最佳内存）中将内容混合在一个单独的牌组上，同时也需要在特定的材料上创建临时牌组，例如在测试之前。<strong>一般的规则是，如果你总是希望能够单独学习一些内容，它应该是在一个正常的牌组上，如果你只是偶尔需要能够单独学习（测试，有压力时，等），标签&#x2F;字段和过滤牌组更好。</strong></p>
</blockquote>
<p>由上可知，官方的建议是不要创建许多小分类牌组，使用几个单独学习的大类牌组即可。强迫症患者可以使用标签或字段来细分类内容，替代创建许多小分类牌组。</p>
<h1 id="极简牌组结构"><a href="#极简牌组结构" class="headerlink" title="极简牌组结构"></a>极简牌组结构</h1><p><img src="/../images/extermely_simple_anki_struct.png" alt="极简Anki牌组结构"></p>
<table>
<thead>
<tr>
<th>牌组名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>00-全部</td>
<td>存放“有效”卡片</td>
</tr>
<tr>
<td>01-迭代</td>
<td>存放“待修改”卡片</td>
</tr>
<tr>
<td>99-归档</td>
<td>存放“废弃”卡片</td>
</tr>
</tbody></table>
<ul>
<li>有效：需要学习&#x2F;复习&#x2F;记忆的卡片；</li>
<li>待修改：内容不好影响记忆效果，需要修改的卡片；</li>
<li>废弃：内容过时，已经不需要记忆的卡片；</li>
</ul>
<h2 id="“00-全部”牌组"><a href="#“00-全部”牌组" class="headerlink" title="“00-全部”牌组"></a>“00-全部”牌组</h2><p>Anki 中的“有效”卡片最终都是要内化到大脑记忆的，那么卡片也就不需要分类了。用易于记忆的方式组织好卡片的内容，记忆到大脑中后，大脑这台高端分类机器会自动分类的。<br><strong>过度分类最大的弊端是破坏了“间隔重复算法”的有效性。</strong> 因为不同类别的卡片记忆难度是不同的，人为分类之后，你会常常在不经意间选择记忆轻松简单的牌组，而不是靠“间隔重复算法”自动为你选择当前最需要复习的卡片。<br>所以，要记忆的“有效”卡片请全都放到“00-全部”牌组。<strong>如果控制不住自己要进行分类，那么问自己“分类通常是为了区分重要程度，既然有不太重要的卡片，直接归档&#x2F;删除即可，何必要分类？”</strong></p>
<h2 id="“01-迭代”牌组"><a href="#“01-迭代”牌组" class="headerlink" title="“01-迭代”牌组"></a>“01-迭代”牌组</h2><p>Anki 卡片内容组织方式是使用 Anki 的难点，卡片内容无法一步到位，通常需要多次的迭代修改。如果多次复习某张卡片时都难以回想起来，那么主要有两种可能的原因：</p>
<ol>
<li>没有理解卡片对应的知识，靠死记硬背；</li>
<li>卡片的内容组织方式不当，大脑难以记忆。</li>
</ol>
<p>解决第 1 点问题的方式因人而异，毕竟 Anki 只是记忆工具。如何系统的学习和理解新知识超出了 Anki 的范畴，这方面大家可以求助于讲解学习方法的相关书籍。</p>
<p>第 2 点问题。目前我还没找到“间隔重复”学习理论的专著，只有知乎上的 Anki 爱好者们和 SuperMemo 的博客有一些零星的文章。<strong>卡片内容组织方面，推荐阅读 SuperMemo 的一篇博文《有效学习：组织知识的20条原则》</strong>[<a target="_blank" rel="noopener" href="https://www.supermemo.com/en/archives1990-2015/articles/20rules">英文</a>][<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/163462164a5b">中文</a>]。文章表达的核心观点就是卡片不能把一大堆内容堆砌在卡片中，期望通过间隔重复的方式来记忆，这样是行不通的。卡片的内容要遵循“最小信息原则”，一张卡片只记忆一个极其简单的知识点。</p>
<p>按我的理解，不管是用问答的形式还是填空形式，<strong>一张卡片最好在 5s 内能快速回想出答案，快速、高频、精准的刺激对应的脑回路，才能形成长期记忆。</strong> 问题和答案没啥强关联，想半天想不出答案，或者答案是好几百字的一大段文字等，都是无法记忆的不合格卡片，需要转移到“01-迭代”牌组进行优化拆分后，再回到“00-全部”牌组进行记忆。</p>
<h2 id="“99-归档”牌组"><a href="#“99-归档”牌组" class="headerlink" title="“99-归档”牌组"></a>“99-归档”牌组</h2><p>做卡片不易，要耗费很多时间精力，有时候看到过时无用的卡片不舍得删，所以存在这个牌组。由于存放在这个牌组的卡片都是“废弃”的卡片，所以牌组学习新卡片和复习卡片的数量都设置为“0”，以免出现数字提醒干扰。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Anki 虽好，可不要瞎折腾。花太多时间在牌组的结构上就属于没有意义的瞎折腾，钻研卡片的内容组织方式才是对使用 Anki 真正有意义的事情^_^。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Anki 2.0 用户手册，<a target="_blank" rel="noopener" href="https://www.ankichina.net/Index/ankishouce">https://www.ankichina.net/Index/ankishouce</a><br>[2] 有效学习——组织知识的20个原则，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/163462164a5b">https://www.jianshu.com/p/163462164a5b</a></p>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans">创意共享4.0许可证</a>）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/10/15/how_long_english_fluently/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/15/how_long_english_fluently/" class="post-title-link" itemprop="url">How long does an adault speak english fluently by english learning applications ?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-15 11:26:25" itemprop="dateCreated datePublished" datetime="2023-10-15T11:26:25+08:00">2023-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/10/15/how_long_english_fluently/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/10/15/how_long_english_fluently/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>I used to learn english by Duolingo.</p>
<p><img src="/../images/duolingo_screenshot.jpg" alt="Duolingo App"></p>
<p>But Duolingo only has a little speak pratice, so i always try to find an better english speaking app.</p>
<p>At last year, ChatGPT became more and more popular. I thought may be some english learning applications could used the chatgpt’s AI feature to make a AI tutor. I searched by google, then i found the application “Speak”.It’s amazing app! I can speak to AI tutor, just like a real person. </p>
<p><img src="/../images/speak_screenshot.jpg" alt="Speak App"></p>
<p>I think it may be helping me to speak english fluently in six months.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/06/11/A%20guide%20to%20own%20a%20long-term%20chatgpt%20account%20in%20chinese%20mainland/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/11/A%20guide%20to%20own%20a%20long-term%20chatgpt%20account%20in%20chinese%20mainland/" class="post-title-link" itemprop="url">A guide to own a long-term chatgpt account in chinese mainland</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-11 23:07:00" itemprop="dateCreated datePublished" datetime="2023-06-11T23:07:00+08:00">2023-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/06/11/A%20guide%20to%20own%20a%20long-term%20chatgpt%20account%20in%20chinese%20mainland/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/06/11/A guide to own a long-term chatgpt account in chinese mainland/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Buy-an-overseas-mobile-phone-physical-card"><a href="#Buy-an-overseas-mobile-phone-physical-card" class="headerlink" title="Buy an overseas mobile phone physical card"></a>Buy an overseas mobile phone physical card</h1><p>Tailand mobile phone card, AIS green card, message card, 10 THB delay validity a month, no voice and network traffic:<br><a target="_blank" rel="noopener" href="https://xunihao.net/product/thailand-ais">https://xunihao.net/product/thailand-ais</a></p>
<p>Taobao guarantee transaction, buy the “fill price difference(补差价)” product:<br><a target="_blank" rel="noopener" href="https://item.taobao.com/item.htm?ft=t&id=709261038665">https://item.taobao.com/item.htm?ft=t&amp;id=709261038665</a></p>
<p>Purchase 30 products, comment “Tailand mobile phone card, AIS green card, message card(泰国电话卡AIS绿卡短信卡)” at order form, the shopkeeper will deliver the card to you by expressage.</p>
<p>When you receive the card, plugin it into your 4G mobile phone, then visit the WeChat public account “Franwell弗兰威尔” to charge the card balance. At least 10 THB each charge to delay validity a month.</p>
<p>Notice! Delay validity a month because of a charge operate, the AIS  not deduct each month. You can charge 12 times to delay a year.</p>
<p>About the card number:</p>
<p>Area code: +66</p>
<p>Country Name：Tailand</p>
<p>If number is 0998877666 (total 10 digit)</p>
<p>When you register any service account, select the country code +66, input the phone number 998877666 (ignore the first digit 0)</p>
<h1 id="Register-an-overseas-email-account"><a href="#Register-an-overseas-email-account" class="headerlink" title="Register an overseas email account"></a>Register an overseas email account</h1><p>Visit Proton(<a target="_blank" rel="noopener" href="https://proton.me/">https://proton.me/</a>), register an email account. Becase of Proton forbit the AIS phone number to verify account, you have to use your other email to verify it.</p>
<h1 id="Register-a-chatgpt-account"><a href="#Register-a-chatgpt-account" class="headerlink" title="Register a chatgpt account"></a>Register a chatgpt account</h1><p>Some tips to increase the odds of success:</p>
<ol>
<li>Open web browser’s privacy model, avoid to be recognized that you are in chinese mainland.</li>
<li>Proxy over the GFW to northern european countries, avoid to be restrict registion by Southeast Asia,HongKong,Macow’s IP address.</li>
<li>Don’t use chinese email, recommend to use Proton email.</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://m.youtube.com/watch?v=NWJeRBMpsx8">【2023最新】在国内也可以轻松注册 ChatGPT 和 OpenAI</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/374452580?utm_id=0">泰国Ais（绿卡）&#x2F;TrueMove（红卡）说明书</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yeyuzhen.github.io/2023/02/05/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eason Ye">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Eason's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/05/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">我的新博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-05 22:14:37" itemprop="dateCreated datePublished" datetime="2023-02-05T22:14:37+08:00">2023-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-05 14:36:44" itemprop="dateModified" datetime="2024-05-05T14:36:44+08:00">2024-05-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/02/05/%E6%88%91%E7%9A%84%E6%96%B0%E5%8D%9A%E5%AE%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/02/05/我的新博客/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>阿里云的服务器忘记续费，导致之前用 Flask 搭的博客数据全没了。考虑了一下，还是用 Hexo 在 Github 上搭博客，本地和远端都有 Git 仓库保存全量数据，不容易丢失。虽然需要科学上网才能访问 Github，但是不会科学上网的人似乎也不需要看技术博客，所以网络问题影响也不大。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eason Ye</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"blog-eason","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
